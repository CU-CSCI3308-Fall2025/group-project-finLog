// *****************************************************
// <!-- Section 1 : Import Dependencies -->
// *****************************************************

const express = require("express");
const bodyParser = require("body-parser");
const pgp = require('pg-promise')();
const session = require('express-session');
const bcrypt = require('bcryptjs');
const { upload, storeImage } = require('../ProjectSourceCode/storeImage');
const fs = require('fs');
const path = require('path');

// *****************************************************
// <!-- Section 2 : Initialization -->
// *****************************************************

// defining the Express app
const app = express();
// using bodyParser to parse JSON in the request body into JS objects
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Database connection details
const dbConfig = {
  host: process.env.POSTGRES_HOST,
  port: 5432,
  database: process.env.POSTGRES_DB,
  user: process.env.POSTGRES_USER,
  password: process.env.POSTGRES_PASSWORD,
};

// Connect to database using the above details
const db = pgp(dbConfig);

// Test database connection
db.connect()
  .then(obj => {
    console.log('Database connection successful');
    obj.done(); // success, release the connection;
  })
  .catch(error => {
    console.log('ERROR:', error.message || error);
  });


// ðŸ”½ ADD THIS BLOCK HERE ðŸ”½
async function runMigrations() {
  try {
    const createSql = fs.readFileSync(
      path.join(__dirname, 'init_data', '00_create.sql'),
      'utf8'
    );

    const insertSql = fs.readFileSync(
      path.join(__dirname, 'init_data', '01_insert.sql'),
      'utf8'
    );

    await db.none(createSql);

    if (insertSql.trim().length > 0) {
      await db.none(insertSql);
    }

    console.log('Database initialized or already up to date.');
  } catch (err) {
    console.error('Migration error (often safe after first run):', err.message);
  }
}

runMigrations();

// Session configuration
app.use(
  session({
    secret: process.env.SESSION_SECRET || 'super_secret_key',
    saveUninitialized: false,
    resave: false,
  })
);

// Serve static files from ProjectSourceCode directory
app.use(express.static('ProjectSourceCode'));

// Serve uploaded images
app.use('/user_images', express.static('user_images'));

// *****************************************************
// <!-- Section 3 : API Routes -->
// *****************************************************

// Redirect root to home page
app.get("/", (req, res) => {
  res.redirect('/home.html');
});

app.get("/welcome", (req, res) => {
  res.json({ status: "success", message: "Welcome!" });
});

app.get('/register', (req, res) => {
  res.sendFile('register.html', { root: './ProjectSourceCode' });
});

app.post('/register', async (req, res) => {
  try {
    // Check if username already exists
    const usernameQuery = `SELECT * FROM users WHERE username = $1`;
    const existingUsername = await db.oneOrNone(usernameQuery, [req.body.username]);
    
    if (existingUsername) {
      return res.status(400).json({
        status: 'error',
        message: 'Username already taken. Please pick a different username.'
      });
    }

    // Check if email already exists (only if email provided)
    if (req.body.email) {
      const emailQuery = `SELECT * FROM users WHERE user_email = $1`;
      const existingEmail = await db.oneOrNone(emailQuery, [req.body.email]);
      
      if (existingEmail) {
        return res.status(400).json({
          status: 'error',
          message: 'Email is already registered. Please use a different email or login.'
        });
      }
    }

    // Hash password and insert new user (user_id is auto-generated by SERIAL)
    const hash = await bcrypt.hash(req.body.password, 10);
    const insertQuery = `
      INSERT INTO users (username, user_email, user_password, date_created)
      VALUES ($1, $2, $3, CURRENT_TIMESTAMP)
      RETURNING *;
    `;
    const values = [req.body.username, req.body.email || null, hash];

    await db.query(insertQuery, values);
    res.status(200).json({
      status: 'success',
      message: 'Registration successful! Please login.'
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Registration failed. Please try again.'
    });
  }
});

app.get('/login', (req, res) => {
  res.sendFile('login.html', { root: './ProjectSourceCode' });
});

app.post('/login', async (req, res) => {
  try {
    const query = `SELECT * FROM users WHERE username = $1`;
    const user = await db.oneOrNone(query, [req.body.username]);

    if (!user) {
      return res.status(401).json({
        status: 'error',
        message: 'Username not found.'
      });
    }

    const match = await bcrypt.compare(req.body.password, user.user_password);

    if (match) {
      // Check if user is moderator or admin
      const moderatorQuery = `SELECT * FROM moderators WHERE user_id = $1`;
      const moderator = await db.oneOrNone(moderatorQuery, [user.user_id]);
      
      let role = 'user'; // Default role
      if (moderator) {
        role = moderator.admin_power; // 'moderator' or 'admin'
      }
      
      req.session.user = user;
      req.session.role = role; // Store role in session
      req.session.save();
      
      res.status(200).json({
        status: 'success',
        message: 'Login successful!',
        user: { 
          username: user.username, 
          user_id: user.user_id,
          role: role // Return role to frontend
        }
      });
    } else {
      res.status(401).json({
        status: 'error',
        message: 'Incorrect password.'
      });
    }
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Login failed. Please try again.'
    });
  }
});

// Upload endpoint for images
app.post('/upload', upload.single('image'), async (req, res) => {
  await storeImage(req, res, db);
});

// New endpoint: Analyze image before upload
app.post('/api/analyze-image', upload.single('image'), async (req, res) => {
  const { analyzeFishWithAI } = require('../ProjectSourceCode/ai_upload');
  const { parseAIResponse, formatAnalysisForDisplay } = require('../ProjectSourceCode/ai_parser');
  const fs = require('fs');
  
  try {
    if (!req.file) {
      return res.status(400).json({
        status: 'error',
        message: 'No image file provided'
      });
    }
    
    // Analyze the image
    const rawAIResponse = await analyzeFishWithAI(req.file.path);
    
    if (!rawAIResponse) {
      // Clean up temp file
      fs.unlinkSync(req.file.path);
      return res.status(500).json({
        status: 'error',
        message: 'AI analysis failed. Please try again.'
      });
    }
    
    // Parse the response
    const parsedData = parseAIResponse(rawAIResponse);
    
    // Check if it's a fish
    if (parsedData.isFish === false) {
      // Not a fish - clean up and reject
      fs.unlinkSync(req.file.path);
      return res.status(400).json({
        status: 'not_fish',
        message: parsedData.reason || 'This image does not appear to contain a fish. Please upload an image of a fish.',
        data: parsedData
      });
    }
    
    // It's a fish - format for display
    const formattedHTML = formatAnalysisForDisplay(parsedData);
    
    // Clean up the temp file (we'll upload again with the form)
    fs.unlinkSync(req.file.path);
    
    res.status(200).json({
      status: 'success',
      message: 'Fish identified successfully',
      data: parsedData,
      aiAnalysisHTML: formattedHTML
    });
    
  } catch (error) {
    console.error('Image analysis error:', error);
    
    // Clean up temp file if it exists
    if (req.file && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }
    
    res.status(500).json({
      status: 'error',
      message: 'Failed to analyze image',
      error: error.message
    });
  }
});

// Get all locations with post data
app.get('/api/locations', async (req, res) => {
  try {
    const query = `
      SELECT 
        l.post_id,
        l.x_coord,
        l.y_coord,
        p.caption,
        p.date_created,
        u.username
      FROM location l
      JOIN posts p ON l.post_id = p.post_id
      JOIN users u ON p.user_id = u.user_id
      ORDER BY p.date_created DESC;
    `;
    
    const locations = await db.any(query);
    res.status(200).json({
      status: 'success',
      data: locations
    });
  } catch (error) {
    console.error('Error fetching locations:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to fetch locations'
    });
  }
});

//comments

app.get('/api/posts/:postId/comments', async (req, res) => {
  try {
    const { postId } = req.params;

    const query = `
      SELECT 
        c.comment_id,
        c.comment_text,
        c.date_created,
        u.username,
        u.user_id
      FROM comments c
      JOIN users u ON c.user_id = u.user_id
      WHERE c.post_id = $1
      ORDER BY c.date_created ASC
    `;

    const result = await db.any(query, [postId]);

    res.json({
      status: "success",
      data: result
    });

  } catch (error) {
    console.error("Error fetching comments:", error);
    res.status(500).json({
      status: "error",
      message: "Failed to fetch comments"
    });
  }
});

// POST /api/posts/:postId/comments - Create a new comment
app.post('/api/posts/:postId/comments', async (req, res) => {
  try {
    const { postId } = req.params;
    const { comment_text } = req.body;
    
    // FIXED: Use req.session.user.user_id (matching your auth pattern)
    if (!req.session.user) {
      return res.status(401).json({
        status: "error",
        message: "You must be logged in to comment"
      });
    }

    const userId = req.session.user.user_id;

    if (!comment_text || comment_text.trim().length === 0) {
      return res.status(400).json({
        status: "error",
        message: "Comment text is required"
      });
    }

    const query = `
      INSERT INTO comments (user_id, post_id, comment_text, date_created)
      VALUES ($1, $2, $3, NOW())
      RETURNING comment_id, comment_text, date_created
    `;

    const result = await db.one(query, [userId, postId, comment_text.trim()]);

    res.json({
      status: "success",
      data: result,
      message: "Comment posted successfully"
    });

  } catch (error) {
    console.error("Error posting comment:", error);
    res.status(500).json({
      status: "error",
      message: "Failed to post comment"
    });
  }
});
// DELETE /api/comments/:commentId - Delete a comment
app.delete('/api/comments/:commentId', async (req, res) => {
  try {
    const { commentId } = req.params;
  
    if (!req.session.user) {
      return res.status(401).json({
        status: "error",
        message: "Unauthorized"
      });
    }

    const userId = req.session.user.user_id;
    const query = `
      DELETE FROM comments 
      WHERE comment_id = $1 AND user_id = $2
      RETURNING comment_id
    `;

    const result = await db.oneOrNone(query, [commentId, userId]);

    if (!result) {
      return res.status(403).json({
        status: "error",
        message: "Cannot delete this comment"
      });
    }

    res.json({
      status: "success",
      message: "Comment deleted successfully"
    });

  } catch (error) {
    console.error("Error deleting comment:", error);
    res.status(500).json({
      status: "error",
      message: "Failed to delete comment"
    });
  }
});

// Check if user is authenticated
app.get('/api/auth/check', async (req, res) => {
  if (req.session.user) {
    // Check role if not already in session (for backward compatibility)
    let role = req.session.role;
    if (!role) {
      const moderator = await db.oneOrNone(
        'SELECT * FROM moderators WHERE user_id = $1',
        [req.session.user.user_id]
      );
      role = moderator ? moderator.admin_power : 'user';
      req.session.role = role;
    }
    
    res.status(200).json({
      status: 'success',
      authenticated: true,
      user: {
        user_id: req.session.user.user_id,
        username: req.session.user.username,
        user_email: req.session.user.user_email,
        role: role // Include role in response
      }
    });
  } else {
    res.status(200).json({
      status: 'success',
      authenticated: false
    });
  }
});

// Logout endpoint
app.get('/logout', (req, res) => {
  req.session.destroy((err) => {
    if (err) {
      return res.status(500).json({ status: 'error', message: 'Logout failed' });
    }
    res.redirect('/home.html');
  });
});

// *****************************************************
// <!-- Admin Middleware -->
// *****************************************************

// Middleware: Require moderator OR admin (both can access)
const requireModerator = async (req, res, next) => {
  if (!req.session.user) {
    return res.status(401).json({ status: 'error', message: 'Not authenticated' });
  }
  
  // Check role in session first
  let role = req.session.role;
  if (!role) {
    const moderator = await db.oneOrNone(
      'SELECT * FROM moderators WHERE user_id = $1',
      [req.session.user.user_id]
    );
    role = moderator ? moderator.admin_power : 'user';
    req.session.role = role;
  }
  
  if (role === 'user') {
    return res.status(403).json({ status: 'error', message: 'Moderator access required' });
  }
  
  // Store role in request for use in route handlers
  req.userRole = role;
  next();
};

// Middleware: Require admin ONLY (higher tier)
const requireAdmin = async (req, res, next) => {
  if (!req.session.user) {
    return res.status(401).json({ status: 'error', message: 'Not authenticated' });
  }
  
  // Check role in session first
  let role = req.session.role;
  if (!role) {
    const moderator = await db.oneOrNone(
      'SELECT * FROM moderators WHERE user_id = $1',
      [req.session.user.user_id]
    );
    role = moderator ? moderator.admin_power : 'user';
    req.session.role = role;
  }
  
  if (role !== 'admin') {
    return res.status(403).json({ 
      status: 'error', 
      message: 'Admin access required. Moderators do not have permission.' 
    });
  }
  
  req.userRole = 'admin';
  next();
};

// *****************************************************
// <!-- Admin API Routes -->
// *****************************************************

// User deletes their own post
app.delete('/api/user/posts/:id', async (req, res) => {
  try {
    // Must be logged in
    if (!req.session.user) {
      return res.status(401).json({
        status: 'error',
        message: 'Not authenticated'
      });
    }

    const userId = req.session.user.user_id;
    const postId = req.params.id;

    // Step 1: Verify post belongs to this user
    const post = await db.oneOrNone(
      `SELECT post_id FROM posts WHERE post_id = $1 AND user_id = $2`,
      [postId, userId]
    );

    if (!post) {
      return res.status(403).json({
        status: 'error',
        message: 'You do not have permission to delete this post'
      });
    }

    // Step 2: Delete image file
    const extensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
    for (const ext of extensions) {
      const filePath = path.join(__dirname, '../user_images', `${postId}${ext}`);
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
        break;
      }
    }

    // Step 3: Delete comments
    await db.none(`DELETE FROM comments WHERE post_id = $1`, [postId]);

    // Step 4: Delete location if exists
    await db.none(`DELETE FROM location WHERE post_id = $1`, [postId]);

    // Step 5: Delete the post record
    await db.none(`DELETE FROM posts WHERE post_id = $1`, [postId]);

    res.status(200).json({
      status: 'success',
      message: 'Your post was deleted'
    });

  } catch (error) {
    console.error('Error deleting user post:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to delete post'
    });
  }
});


// Get all posts for moderation (moderators + admins)
app.get('/api/admin/posts', requireModerator, async (req, res) => {
  try {
    const query = `
      SELECT 
        p.post_id,
        p.caption,
        p.date_created,
        p.status,
        u.username,
        u.user_id
      FROM posts p
      JOIN users u ON p.user_id = u.user_id
      ORDER BY p.date_created DESC;
    `;
    
    const posts = await db.any(query);
    
    // Add image path to each post
    const postsWithImages = posts.map(post => {
      const extensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
      let imagePath = null;
      
      for (const ext of extensions) {
        const filePath = path.join(__dirname, '../user_images', `${post.post_id}${ext}`);
        if (fs.existsSync(filePath)) {
          imagePath = `/user_images/${post.post_id}${ext}`;
          break;
        }
      }
      
      return {
        ...post,
        image_path: imagePath || `/user_images/${post.post_id}.jpg`
      };
    });
    
    res.status(200).json({
      status: 'success',
      data: postsWithImages
    });
  } catch (error) {
    console.error('Error fetching admin posts:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to fetch posts'
    });
  }
});

// Update post status (approve, flag, pending) - moderators + admins
app.put('/api/admin/posts/:id/status', requireModerator, async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    
    if (!['pending', 'approved', 'flagged'].includes(status)) {
      return res.status(400).json({
        status: 'error',
        message: 'Invalid status. Must be: pending, approved, or flagged'
      });
    }
    
    const query = `UPDATE posts SET status = $1 WHERE post_id = $2 RETURNING *`;
    const updated = await db.one(query, [status, id]);
    
    res.status(200).json({
      status: 'success',
      message: 'Post status updated',
      data: updated
    });
  } catch (error) {
    console.error('Error updating post status:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to update post status'
    });
  }
});

// Delete post permanently (admins only)
app.delete('/api/admin/posts/:id', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const query = `DELETE FROM posts WHERE post_id = $1 RETURNING *`;
    const deleted = await db.one(query, [id]);
    
    res.status(200).json({
      status: 'success',
      message: 'Post deleted',
      data: deleted
    });
  } catch (error) {
    console.error('Error deleting post:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to delete post'
    });
  }
});

// Get user stats
app.get('/api/user/stats', async (req, res) => {
  try {
    if (!req.session.user) {
      return res.status(401).json({ status: 'error', message: 'Not authenticated' });
    }

    const userId = req.session.user.user_id;

    const statsQuery = `
      SELECT
        (SELECT COUNT(*) FROM posts WHERE user_id = $1) as total_catches,
        (SELECT COUNT(DISTINCT fish_species) FROM posts WHERE user_id = $1) as species_count,
        (SELECT MAX(fish_weight) FROM posts WHERE user_id = $1) as largest_catch,
        (SELECT date_created FROM users WHERE user_id = $1) as user_creation_date
      FROM users
      WHERE user_id = $1;
    `;

    const stats = await db.one(statsQuery, [userId]);

    res.status(200).json({
      status: 'success',
      data: stats
    });
  } catch (error) {
    console.error('Error fetching user stats:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to fetch user stats'
    });
  }
});

// Get current user's posts
app.get('/api/user/posts', async (req, res) => {
  try {
    if (!req.session.user) {
      return res.status(401).json({ status: 'error', message: 'Not authenticated' });
    }
    
    const query = `
      SELECT post_id, caption, date_created
      FROM posts
      WHERE user_id = $1
      ORDER BY date_created DESC;
    `;
    
    const posts = await db.any(query, [req.session.user.user_id]);
    
    // Add image path to each post, checking for actual file extension
    const postsWithImages = posts.map(post => {
      const extensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
      let imagePath = null;
      
      for (const ext of extensions) {
        const filePath = path.join(__dirname, '../user_images', `${post.post_id}${ext}`);
        if (fs.existsSync(filePath)) {
          imagePath = `/user_images/${post.post_id}${ext}`;
          break;
        }
      }
      
      return {
        ...post,
        image_path: imagePath || `/user_images/${post.post_id}.jpg` // fallback
      };
    });
    
    res.status(200).json({
      status: 'success',
      data: postsWithImages
    });
  } catch (error) {
    console.error('Error fetching user posts:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to fetch posts'
    });
  }
});

// Get all posts for feed/finlog (WITH LIKE AND COMMENT COUNTS)
app.get('/api/posts', async (req, res) => {
  try {
    const query = `
      SELECT 
        p.post_id,
        p.caption,
        p.date_created,
        p.fish_weight,
        p.fish_species,
        u.username,
        l.x_coord,
        l.y_coord,
        COUNT(DISTINCT lk.user_id) as like_count,
        COUNT(DISTINCT c.comment_id) as comment_count
      FROM posts p
      JOIN users u ON p.user_id = u.user_id
      LEFT JOIN location l ON p.post_id = l.post_id
      LEFT JOIN likes lk ON p.post_id = lk.post_id
      LEFT JOIN comments c ON p.post_id = c.post_id
      GROUP BY p.post_id, u.username, l.x_coord, l.y_coord
      ORDER BY p.date_created DESC
      LIMIT 50;
    `;
    
    const posts = await db.any(query);
    
    // Add image path to each post, checking for actual file extension
    const postsWithImages = posts.map(post => {
      const extensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
      let imagePath = null;
      
      for (const ext of extensions) {
        const filePath = path.join(__dirname, '../user_images', `${post.post_id}${ext}`);
        if (fs.existsSync(filePath)) {
          imagePath = `/user_images/${post.post_id}${ext}`;
          break;
        }
      }
      
      return {
        ...post,
        image_path: imagePath || `/user_images/${post.post_id}.jpg`, // fallback
        like_count: parseInt(post.like_count) || 0,
        comment_count: parseInt(post.comment_count) || 0
      };
    });
    
    res.status(200).json({
      status: 'success',
      data: postsWithImages
    });
  } catch (error) {
    console.error('Error fetching posts:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to fetch posts'
    });
  }
});

// ==================== LIKES ENDPOINTS ====================

// Like/Unlike a post
app.post('/api/posts/:id/like', async (req, res) => {
  try {
    // Check if user is logged in
    if (!req.session.user) {
      return res.status(401).json({
        status: 'error',
        message: 'Must be logged in to like posts'
      });
    }

    const postId = req.params.id;
    const userId = req.session.user.user_id;

    // Check if already liked
    const existingLike = await db.oneOrNone(
      'SELECT * FROM likes WHERE user_id = $1 AND post_id = $2',
      [userId, postId]
    );

    if (existingLike) {
      // Unlike: remove the like
      await db.none(
        'DELETE FROM likes WHERE user_id = $1 AND post_id = $2',
        [userId, postId]
      );
      
      return res.status(200).json({
        status: 'success',
        message: 'Post unliked',
        liked: false
      });
    } else {
      // Like: add the like
      await db.none(
        'INSERT INTO likes (user_id, post_id, liked) VALUES ($1, $2, TRUE)',
        [userId, postId]
      );
      
      return res.status(200).json({
        status: 'success',
        message: 'Post liked',
        liked: true
      });
    }
  } catch (error) {
    console.error('Error toggling like:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to toggle like'
    });
  }
});

// Get like count for a post
app.get('/api/posts/:id/likes', async (req, res) => {
  try {
    const postId = req.params.id;
    
    const result = await db.one(
      'SELECT COUNT(*) as like_count FROM likes WHERE post_id = $1',
      [postId]
    );
    
    // Check if current user liked this post
    let userLiked = false;
    if (req.session.user) {
      const userLike = await db.oneOrNone(
        'SELECT * FROM likes WHERE user_id = $1 AND post_id = $2',
        [req.session.user.user_id, postId]
      );
      userLiked = !!userLike;
    }
    
    res.status(200).json({
      status: 'success',
      data: {
        like_count: parseInt(result.like_count),
        user_liked: userLiked
      }
    });
  } catch (error) {
    console.error('Error fetching likes:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to fetch likes'
    });
  }
});


module.exports = app.listen(3000, () => {
  console.log('Server is listening on port 3000');
});